import json
from datetime import datetime
from io import BytesIO

import html2text
import pytz
import requests
from django.conf import settings
from django.utils.timezone import now
from loguru import logger

from backend.celery import app
from core.models import Project, TelegramUser, Source, GPTPrompt, Category, Subcategory, GPTRequest
from core.utils import create_infographic


@app.task
def process_order_task(order):
    source = order.pop("source", None)
    if not source:
        logger.critical(f"–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏—Å—Ç–æ—á–Ω–∏–∫: {order}")
        return

    try:
        source = Source.objects.get(
            code=source,
        )
    except Source.DoesNotExist:
        logger.critical(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫: {source}")
        return

    subcategory = order.pop("subcategory", None)
    if not subcategory:
        logger.critical(f"–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è: {subcategory}")
        return

    try:
        subcategory = Subcategory.objects.get(code=subcategory)
    except Exception as exc:
        logger.critical(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è: {subcategory}")
        return

    category = order.pop("category", None)
    if not category:
        category = subcategory.category.code

    try:
        category = Category.objects.get(code=category)
    except Exception as exc:
        logger.critical(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è: {category}")
        return

    project, created = Project.objects.get_or_create(
        project_id=order["project_id"],
        source=source,
        defaults={
            "title": order.get("title"),
            "description": order.get("description"),
            "price": order.get("price"),
            "price_max": order.get("price_max"),
            "url": order.get("url"),
            "offers": order.get("offers"),
            "order_created": order.get("order_created"),
            "category": category,
            "subcategory": subcategory,
            "currency_symbol": order.get("currency_symbol"),
        },
    )
    if created:
        send_project_task.delay(project.id)


def check_words(words, title, description):
    if not words:
        return False

    words = [word.strip().lower() for word in words.split(",")]
    for word in words:
        if word in title.lower() or word in description.lower():
            return True

    return False


@app.task(name="send_project_task")
def send_project_task(project_id):
    project = Project.objects.get(id=project_id)
    if project.status == Project.StatusChoices.DISTRIBUTED:
        return

    order_created_datetime = datetime.fromtimestamp(project.order_created, pytz.UTC)
    time_diff = now() - order_created_datetime
    minutes_ago = int(time_diff.total_seconds() / 60)

    if minutes_ago > 120:
        return

    title = html2text.html2text(project.title).strip()
    title = title.split()
    title = f"{title[0].capitalize()} {' '.join(title[1:])}"
    description = html2text.html2text(project.description).strip()

    price_text = "–ù–µ —É–∫–∞–∑–∞–Ω–∞"
    if project.price:
        price_text = ""
        if project.price and project.price_max:
            price_text = f"–æ—Ç {int(project.price)} –¥–æ {int(project.price_max)} "
        elif project.price:
            price_text = f"{int(project.price)} "
        elif project.price_max:
            price_text = f"{int(project.price_max)} "

        price_text += project.currency_symbol

    users = TelegramUser.objects.filter(
        category_subscriptions__subcategory=project.subcategory,
        source_subscriptions__source=project.source,
    ).distinct()

    keyboard = {
        "inline_keyboard": [
            [{"text": "üåê –ü–µ—Ä–µ–π—Ç–∏ –∫ –∑–∞–∫–∞–∑—É", "url": project.url}],
            [{"text": "ü§ñÔ∏è –°–æ—Å—Ç–∞–≤–∏—Ç—å –æ—Ç–∫–ª–∏–∫ (1 —Ç–æ–∫–µ–Ω)", "callback_data": f"project:response:{project.id}:"}],
            [{"text": "üöÄ –°–æ—Å—Ç–∞–≤–∏—Ç—å —Ä–µ—à–µ–Ω–∏–µ (2 —Ç–æ–∫–µ–Ω–∞)", "callback_data": f"project:analyze:{project.id}:"}],
            [{"text": "‚ö†Ô∏è –°–æ–æ–±—â–∏—Ç—å –æ–± –æ—à–∏–±–∫–µ", "callback_data": f"project:complain:{project.id}:"}],
            [{"text": "‚ùå –ó–∞–∫—Ä—ã—Ç—å", "callback_data": "close"}]
        ]
    }

    url = f"https://api.telegram.org/bot{settings.TELEGRAM_BOT_TOKEN}/sendPhoto"
    img_data = create_infographic(
        title,
        price_text,
        project.source.title,
        project.offers,
        minutes_ago,
        project.subcategory.title,
    )
    response = requests.post(
        url,
        data={
            "chat_id": -1002238232891,
            "message_thread_id": 2,
        },
        files={
            "photo": BytesIO(img_data)
        }
    )

    file_id = response.json()["result"]["photo"][-1]["file_id"]

    for user in users:
        if user.stop_words and user.stop_words.strip():
            has_stop_word = check_words(user.stop_words.strip(), title, description)
            if has_stop_word:
                continue

        if user.keywords and user.keywords.strip():
            has_keyword = check_words(user.keywords.strip(), title, description)
            if not has_keyword:
                continue

        if len(description) > 350:
            caption = f"{description[:350]}...."
        else:
            caption = description

        payload = {
            "chat_id": user.chat_id,
            "caption": caption,
            "reply_markup": json.dumps(keyboard),
            "photo": file_id,
        }
        response = requests.post(url, data=payload)
        if response.status_code != 200:
            print(f"Failed to send message to {user.chat_id}: {response.text}")
            return

    project.status = Project.StatusChoices.DISTRIBUTED
    project.save()


def send_limit_exceeded_message(chat_id, delete_message_id):
    keyboard = json.dumps({
        "inline_keyboard": [[{
            "text": "ü™ô –ü–æ–ø–æ–ª–Ω–∏—Ç—å —Ç–æ–∫–µ–Ω—ã",
            "callback_data": f"token:get:::"
        }]]
    })

    data = {
        'chat_id': chat_id,
        'message_id': delete_message_id,
        'text': (
            "üö´ *–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ç–æ–∫–µ–Ω–æ–≤.*\n\n"
            "–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –ø–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å."
        ),
        'parse_mode': 'Markdown',
        'reply_markup': keyboard
    }
    url = f"https://api.telegram.org/bot{settings.TELEGRAM_BOT_TOKEN}/editMessageText"
    response = requests.post(url, json=data)
    return response.json()


def send_edit_keyboard_message(chat_id, request_id, delete_message_id, project_id):
    keyboard = json.dumps({
        "inline_keyboard": [[{
            "text": "‚ö†Ô∏è –°–æ–æ–±—â–∏—Ç—å –æ–± –æ—à–∏–±–∫–µ",
            "callback_data": f"gpt:{request_id}:complain:{project_id}:"
        }]]
    })

    data = {
        'chat_id': chat_id,
        'message_id': delete_message_id,
        'parse_mode': 'Markdown',
        'reply_markup': keyboard
    }
    url = f"https://api.telegram.org/bot{settings.TELEGRAM_BOT_TOKEN}/editMessageReplyMarkup"
    response = requests.post(url, json=data)
    return response.json()


@app.task(name="gpt_request")
def gpt_request(project_id, message_id, delete_message_id, chat_id, request_type, additional_info):
    try:
        user = TelegramUser.objects.get(chat_id=chat_id)
    except TelegramUser.DoesNotExist as exc:
        return

    if user.tokens <= 0:
        send_limit_exceeded_message(user.chat_id, delete_message_id)
        return

    project = Project.objects.get(id=project_id)
    prompt = GPTPrompt.objects.get(
        model__code="gpt-4o",
        type=request_type,
        category=project.category,
    )
    request = GPTRequest.objects.create(
        prompt=prompt,
        user=user,
        project=project,
        type=request_type,
        additional_info=additional_info,
    )
    send_edit_keyboard_message(chat_id, request.id, delete_message_id, project_id)
    request.send_user_response(message_id, delete_message_id)
